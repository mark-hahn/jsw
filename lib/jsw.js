// Generated by CoffeeScript 1.9.3

/*
  jsw.coffee
  A translator for an alternate Javascript syntax that uses significant whitespace
 */

(function() {
  var Uglify, addContexts, args, ast, base64, crypto, dumpAst, file, fn, fs, idx, j, jsCode, jswCode, jswCodeStream, jswMap, jswMappings, k, key, l, len, len1, len2, log, m, meta, metaBase64, metaLines, node_map, pfx, ref, streamOpts, util, val, val2, zlib;

  log = require('debug')('jsw');

  fs = require('fs');

  util = require('util');

  args = require('./args');

  Uglify = require("uglify-js2");

  crypto = require('crypto');

  zlib = require('zlib');

  dumpAst = function(ast) {
    var tt;
    tt = new Uglify.TreeTransformer(null, function(node) {
      node.startPos = node.start.pos;
      node.endPos = node.end.pos;
      delete node.start;
      delete node.end;
      node.type = node.TYPE;
      if ((node.body == null) || node.body.length === 0) {
        delete node.body;
      }
      return node;
    });
    fs.writeFileSync(pfx + 'dump.json', JSON.stringify(ast.transform(tt)));
    return ast;
  };

  ref = args.files;
  for (j = 0, len = ref.length; j < len; j++) {
    file = ref[j];
    console.log("\nvvvvvvvvvvvvvvvvvv");
    pfx = 'test/';
    jsCode = fs.readFileSync(file, 'utf8');
    if (args.tojsw) {
      ast = Uglify.parse(jsCode);
      dumpAst(ast);
      fs.writeFileSync(pfx + 'tojsw-ast.json', JSON.stringify(ast));
      jswMappings = [];
      node_map = {
        add: function(node_gen_map) {
          return jswMappings.push(node_gen_map);
        }
      };
      streamOpts = {
        beautify: true,
        indent_level: 2,
        node_map: node_map
      };
      jswCodeStream = Uglify.OutputStream(streamOpts);
      ast.print(jswCodeStream);
      jswCode = jswCodeStream.toString();
      addContexts = function(map) {
        var addOneCtx;
        addOneCtx = function(key, pos, dir) {
          var chr, ctx, i, k;
          ctx = '';
          for (i = k = 1; k <= 100; i = ++k) {
            pos += i * dir;
            if ((chr = jswCode[pos]) == null) {
              break;
            }
            ctx += chr;
          }
          return map[key] = ctx.replace(/[\x00-\x1f]/g, '~');
        };
        addOneCtx('topCtx', map.gen_start_pos, -1);
        addOneCtx('botCtx', map.gen_end_pos - 1, +1);
        return map;
      };
      meta = {};
      fn = function() {
        var gen_end_pos, gen_start_pos, hash, jswCodeNode, key, metaMap, orig_end_pos, orig_start_pos, type, val;
        type = jswMap.type, orig_start_pos = jswMap.orig_start_pos, orig_end_pos = jswMap.orig_end_pos, gen_start_pos = jswMap.gen_start_pos, gen_end_pos = jswMap.gen_end_pos;
        jswCodeNode = jswCode.slice(gen_start_pos, gen_end_pos);
        hash = crypto.createHash('md5');
        hash.update(jswCodeNode);
        key = type + '-' + hash.digest('hex');
        metaMap = {
          orig_start_pos: orig_start_pos,
          orig_end_pos: orig_end_pos,
          gen_start_pos: gen_start_pos,
          gen_end_pos: gen_end_pos
        };
        if ((val = meta[key])) {
          if (!Array.isArray(val)) {
            meta[key] = [addContexts(val)];
          }
          return meta[key].push(addContexts(metaMap));
        } else {
          return meta[key] = metaMap;
        }
      };
      for (k = 0, len1 = jswMappings.length; k < len1; k++) {
        jswMap = jswMappings[k];
        fn();
      }
      for (key in meta) {
        val = meta[key];
        if (!Array.isArray(val)) {
          delete val.gen_start_pos;
          delete val.gen_end_pos;
        } else {
          for (l = 0, len2 = val.length; l < len2; l++) {
            val2 = val[l];
            delete val2.gen_start_pos;
            delete val2.gen_end_pos;
          }
        }
      }
      base64 = zlib.deflateSync(JSON.stringify(meta)).toString('base64');
      metaLines = '';
      for (idx = m = 0; m <= 9e9; idx = m += 80) {
        if (idx < base64.length) {
          metaLines += '#' + base64.slice(idx, idx + 80) + '\n';
        }
      }
      metaBase64 = '\n\n### metadata to translate jsw to js losslessly ###\n' + metaLines;
      fs.writeFileSync(pfx + 'meta.json', JSON.stringify(meta));
      fs.writeFileSync(pfx + 'jswCode.jsw', jswCode + metaBase64);
    }
    console.log("^^^^^^^^^^^^^^^^^^\n");
  }

}).call(this);
