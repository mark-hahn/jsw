// Generated by CoffeeScript 1.9.3
(function() {
  var crypto, fs, log, zlib;

  log = require('debug')('meta');

  fs = require('fs');

  crypto = require('crypto');

  zlib = require('zlib');

  exports.encode = function(jsCode, jswCode, jswMappings) {
    var addContexts, base64, fn, idx, j, jswMap, k, key, l, len, len1, meta, metaJson, metaLines, val, val2;
    addContexts = function(map) {
      var addOneCtx;
      addOneCtx = function(key, pos, dir) {
        var chr, ctx, i, j;
        ctx = '';
        for (i = j = 1; j <= 100; i = ++j) {
          pos += i * dir;
          if ((chr = jswCode[pos]) == null) {
            break;
          }
          ctx += chr;
        }
        return map[key] = ctx.replace(/[\x00-\x1f]/g, '~');
      };
      addOneCtx('topCtx', map.gen_start_pos, -1);
      addOneCtx('botCtx', map.gen_end_pos - 1, +1);
      return map;
    };
    meta = {
      vers: 1,
      code: jsCode
    };
    fn = function() {
      var gen_end_pos, gen_start_pos, hash, key, metaMap, orig_end_pos, orig_start_pos, type, val;
      type = jswMap.type, orig_start_pos = jswMap.orig_start_pos, orig_end_pos = jswMap.orig_end_pos, gen_start_pos = jswMap.gen_start_pos, gen_end_pos = jswMap.gen_end_pos;
      hash = crypto.createHash('md5');
      hash.update(jswCode.slice(gen_start_pos, gen_end_pos));
      key = type + '-' + hash.digest('hex');
      metaMap = {
        start: orig_start_pos,
        end: orig_end_pos,
        gen_start_pos: gen_start_pos,
        gen_end_pos: gen_end_pos
      };
      if (!(val = meta[key])) {
        return meta[key] = metaMap;
      } else {
        if (!Array.isArray(val)) {
          meta[key] = [addContexts(val)];
        }
        return meta[key].push(addContexts(metaMap));
      }
    };
    for (j = 0, len = jswMappings.length; j < len; j++) {
      jswMap = jswMappings[j];
      fn();
    }
    for (key in meta) {
      val = meta[key];
      if (!Array.isArray(val)) {
        delete val.gen_start_pos;
        delete val.gen_end_pos;
      } else {
        for (k = 0, len1 = val.length; k < len1; k++) {
          val2 = val[k];
          delete val2.gen_start_pos;
          delete val2.gen_end_pos;
        }
      }
    }
    metaJson = JSON.stringify(meta);
    fs.writeFileSync('test/meta.json', metaJson);
    base64 = zlib.deflateSync(metaJson).toString('base64');
    metaLines = '';
    for (idx = l = 0; l <= 9e9; idx = l += 80) {
      if (idx < base64.length) {
        metaLines += '#' + base64.slice(idx, idx + 80) + '\n';
      }
    }
    return '\n\n### metadata to restore jsw to js losslessly (vers 1) ###\n' + metaLines;
  };

  exports.decode = function(jswCode, metaText) {
    var base64, e, match;
    try {
      if (!metaText) {
        if (!(match = /([\s\S]*)###\smetadata\sto\srestore\sjsw\sto\sjs.*\s(\d+)\)([\s\S]*)/.exec(jswCode)) || +match[2] !== 1) {
          return [];
        }
        metaText = match[3];
      }
      base64 = metaText.replace(/[\s\n\r#]/g, '');
      return [match[1], JSON.parse(zlib.inflateSync(new Buffer(base64, 'base64')).toString())];
    } catch (_error) {
      e = _error;
      log(e);
      return [];
    }
  };

}).call(this);
