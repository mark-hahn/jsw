// Generated by CoffeeScript 1.9.3
(function() {
  var crypto, fs, log, lookup, zlib;

  log = require('debug')('meta');

  fs = require('fs');

  crypto = require('crypto');

  zlib = require('zlib');

  exports.encode = function(jsCode, jswCode, jswMappings) {
    var addContexts, base64, fn, idx, j, jswMap, k, key, l, len, len1, meta, metaJson, metaLines, val, val2;
    addContexts = function(map) {
      var addOneCtx;
      addOneCtx = function(key, pos, dir) {
        var chr, ctx, i, j;
        ctx = '';
        for (i = j = 1; j <= 9000000000; i = ++j) {
          pos += i * dir;
          if ((chr = jswCode[pos]) == null) {
            break;
          }
          ctx += chr;
        }
        return map[key] = ctx;
      };
      addOneCtx('topCtx', map.gen_start_pos, -1);
      addOneCtx('botCtx', map.gen_end_pos - 1, +1);
      return map;
    };
    meta = {
      vers: 1,
      jsCode: jsCode
    };
    fn = function() {
      var gen_end_pos, gen_start_pos, hash, key, metaMap, orig_end_pos, orig_start_pos, type, val;
      type = jswMap.type, orig_start_pos = jswMap.orig_start_pos, orig_end_pos = jswMap.orig_end_pos, gen_start_pos = jswMap.gen_start_pos, gen_end_pos = jswMap.gen_end_pos;
      hash = crypto.createHash('md5');
      hash.update(jswCode.slice(gen_start_pos, gen_end_pos));
      key = type + '-' + hash.digest('hex');
      metaMap = {
        start: orig_start_pos,
        end: orig_end_pos,
        gen_start_pos: gen_start_pos,
        gen_end_pos: gen_end_pos
      };
      if (!(val = meta[key])) {
        return meta[key] = metaMap;
      } else {
        if (!Array.isArray(val)) {
          meta[key] = [addContexts(val)];
        }
        return meta[key].push(addContexts(metaMap));
      }
    };
    for (j = 0, len = jswMappings.length; j < len; j++) {
      jswMap = jswMappings[j];
      fn();
    }
    for (key in meta) {
      val = meta[key];
      if (!Array.isArray(val)) {
        delete val.gen_start_pos;
        delete val.gen_end_pos;
      } else {
        for (k = 0, len1 = val.length; k < len1; k++) {
          val2 = val[k];
          delete val2.gen_start_pos;
          delete val2.gen_end_pos;
        }
      }
    }
    metaJson = JSON.stringify(meta);
    fs.writeFileSync('test/meta.json', metaJson);
    base64 = zlib.deflateSync(metaJson).toString('base64');
    metaLines = '';
    for (idx = l = 0; l <= 9e9; idx = l += 80) {
      if (idx < base64.length) {
        metaLines += '#' + base64.slice(idx, idx + 80) + '\n';
      }
    }
    return '\n\n### metadata to restore jsw to js losslessly (vers 1) ###\n' + metaLines;
  };

  lookup = function(node) {
    var bestMap, bestSpan, botCtx, chkSpan, end, hash, j, key, len, map, metaMap, spanBot, spanTop, start, topCtx;
    chkSpan = (function(_this) {
      return function(ofs, dir, ctx, start) {
        var i, j, ref;
        log('chkSpan1', {
          ofs: ofs,
          dir: dir,
          ctx: ctx,
          start: start
        });
        for (i = j = 0, ref = ctx.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          ofs += i * dir;
          if (ctx[i] !== _this.jswCode[start + ofs]) {
            break;
          }
        }
        if (i === ctx.length) {
          ofs += i * dir;
          if (!_this.jswCode[start + ofs]) {
            log('chkSpan2', {
              i: i,
              start: start,
              ofs: ofs,
              chr: _this.jswCode[start + ofs],
              jswCode: _this.jswCode
            });
            return true;
          }
        }
        log('chkSpan3', {
          i: i,
          clen: ctx.length
        });
        return i;
      };
    })(this);
    hash = crypto.createHash('md5');
    hash.update(this.jswCode.slice(node.start.pos, node.end.endpos));
    key = node.TYPE + '-' + hash.digest('hex');
    log('key', key, this[key]);
    if (!(metaMap = this[key])) {
      return null;
    }
    if (!Array.isArray(metaMap)) {
      log('not Array.isArray', this.jsCode.slice(metaMap.start, metaMap.end));
      return this.jsCode.slice(metaMap.start, metaMap.end);
    }
    bestMap = null;
    bestSpan = -1;
    for (j = 0, len = metaMap.length; j < len; j++) {
      map = metaMap[j];
      log('map', map);
      start = map.start, end = map.end, topCtx = map.topCtx, botCtx = map.botCtx;
      spanTop = chkSpan(-1, -1, topCtx, node.start.pos);
      if (spanTop === true) {
        return this.jsCode.slice(start, end);
      }
      spanBot = chkSpan(0, 1, botCtx, node.end.endpos);
      if (spanBot === true) {
        return this.jsCode.slice(start, end);
      }
      if (spanTop + spanBot > bestSpan) {
        bestSpan = spanTop + spanBot;
        bestMap = map;
      }
    }
    log('bestMap', bestMap);
    if (bestMap) {
      return this.jsCode.slice(bestMap.start, bestMap.end);
    }
  };

  exports.decode = function(jswCode, metaText) {
    var base64, e, match, meta;
    try {
      if (!metaText) {
        if (!(match = /([\s\S]*)###\smetadata\sto\srestore\sjsw\sto\sjs.*\s(\d+)\)([\s\S]*)/.exec(jswCode)) || +match[2] !== 1) {
          return [];
        }
        metaText = match[3];
      }
      base64 = metaText.replace(/[\s\n\r#]/g, '');
      meta = JSON.parse(zlib.inflateSync(new Buffer(base64, 'base64')).toString());
      meta.lookup = lookup;
      return [match[1], meta];
    } catch (_error) {
      e = _error;
      log(e);
      return [];
    }
  };

}).call(this);
