// Generated by CoffeeScript 1.9.3
(function() {
  var BinaryPrecedence, CodeGenerator, E_FFT, E_FTT, E_TFF, E_TFT, E_TTF, E_TTT, FORMAT_DEFAULTS, FORMAT_MINIFY, F_ALLOW_CALL, F_ALLOW_IN, F_ALLOW_UNPARATH_NEW, F_DIRECTIVE_CTX, F_FUNC_BODY, F_SEMICOLON_OPT, Precedence, S_FFFF, S_TFFF, S_TFFT, S_TFTF, S_TTFF, SourceNode, Syntax, addComments, addIndent, adjustMultilineComment, base, calculateSpaces, createSrcNodesFile, crypto, directive, endsWithLineTerminator, escapeAllowedCharacter, escapeDirective, escapeDisallowedCharacter, escapeRegExpCharacter, escapeString, escapeless, estraverse, esutils, extra, flattenToString, fs, generate, generateAsyncPrefix, generateBlankLines, generateComment, generateIdentifier, generateInternal, generateMethodPrefix, generateNumber, generateRegExp, generateStarSuffix, generateVerbatim, generateVerbatimString, getDefaultOptions, hasLineTerminator, hexadecimal, indent, isArray, isExpression, isStatement, join, json, jswIndexes, log, merge, newline, noEmptySpace, origCode, parentheses, parenthesize, parse, preserveBlankLines, quotes, renumber, rimraf, safeConcatenation, semicolons, sourceCode, sourceMap, space, stringRepeat, toSourceNodeWhenNeeded, updateDeeply, withIndent;

  log = require('debug')('genjsw');

  fs = require('fs');

  crypto = require('crypto');

  rimraf = require('rimraf');

  createSrcNodesFile = true;

  Syntax = void 0;

  Precedence = void 0;

  BinaryPrecedence = void 0;

  SourceNode = void 0;

  estraverse = void 0;

  esutils = void 0;

  isArray = void 0;

  base = void 0;

  indent = void 0;

  json = void 0;

  renumber = void 0;

  hexadecimal = void 0;

  quotes = void 0;

  escapeless = void 0;

  newline = void 0;

  space = void 0;

  parentheses = void 0;

  semicolons = void 0;

  safeConcatenation = void 0;

  directive = void 0;

  extra = void 0;

  parse = void 0;

  sourceMap = void 0;

  sourceCode = void 0;

  preserveBlankLines = void 0;

  FORMAT_MINIFY = void 0;

  FORMAT_DEFAULTS = void 0;

  estraverse = require("estraverse");

  esutils = require("esutils");

  Syntax = estraverse.Syntax;

  Precedence = {
    Sequence: 0,
    Yield: 1,
    Await: 1,
    Assignment: 1,
    Conditional: 2,
    ArrowFunction: 2,
    LogicalOR: 3,
    LogicalAND: 4,
    BitwiseOR: 5,
    BitwiseXOR: 6,
    BitwiseAND: 7,
    Equality: 8,
    Relational: 9,
    BitwiseSHIFT: 10,
    Additive: 11,
    Multiplicative: 12,
    Unary: 13,
    Postfix: 14,
    Call: 15,
    New: 16,
    TaggedTemplate: 17,
    Member: 18,
    Primary: 19
  };

  BinaryPrecedence = {
    "||": Precedence.LogicalOR,
    "&&": Precedence.LogicalAND,
    "|": Precedence.BitwiseOR,
    "^": Precedence.BitwiseXOR,
    "&": Precedence.BitwiseAND,
    "==": Precedence.Equality,
    "!=": Precedence.Equality,
    "===": Precedence.Equality,
    "!==": Precedence.Equality,
    is: Precedence.Equality,
    isnt: Precedence.Equality,
    "<": Precedence.Relational,
    ">": Precedence.Relational,
    "<=": Precedence.Relational,
    ">=": Precedence.Relational,
    "in": Precedence.Relational,
    "instanceof": Precedence.Relational,
    "<<": Precedence.BitwiseSHIFT,
    ">>": Precedence.BitwiseSHIFT,
    ">>>": Precedence.BitwiseSHIFT,
    "+": Precedence.Additive,
    "-": Precedence.Additive,
    "*": Precedence.Multiplicative,
    "%": Precedence.Multiplicative,
    "/": Precedence.Multiplicative
  };

  F_ALLOW_IN = 1;

  F_ALLOW_CALL = 1 << 1;

  F_ALLOW_UNPARATH_NEW = 1 << 2;

  F_FUNC_BODY = 1 << 3;

  F_DIRECTIVE_CTX = 1 << 4;

  F_SEMICOLON_OPT = 1 << 5;

  E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW;

  E_TTF = F_ALLOW_IN | F_ALLOW_CALL;

  E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW;

  E_TFF = F_ALLOW_IN;

  E_FFT = F_ALLOW_UNPARATH_NEW;

  E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;

  S_TFFF = F_ALLOW_IN;

  S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT;

  S_FFFF = 0x00;

  S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX;

  S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

  isArray = Array.isArray;

  if (!isArray) {
    isArray = isArray = function(array) {
      return Object.prototype.toString.call(array) === "[object Array]";
    };
  }

  isExpression = function(node) {
    return CodeGenerator.Expression.hasOwnProperty(node.type);
  };

  isStatement = function(node) {
    return CodeGenerator.Statement.hasOwnProperty(node.type);
  };

  getDefaultOptions = function() {
    return {
      indent: null,
      base: null,
      parse: null,
      comment: false,
      format: {
        indent: {
          style: "  ",
          base: 0,
          adjustMultilineComment: false
        },
        newline: "\n",
        space: " ",
        json: false,
        renumber: false,
        hexadecimal: false,
        quotes: "single",
        escapeless: false,
        compact: false,
        parentheses: true,
        semicolons: true,
        safeConcatenation: false,
        preserveBlankLines: false
      },
      moz: {
        comprehensionExpressionStartsWithAssignment: false,
        starlessGenerator: false
      },
      sourceMap: null,
      sourceMapRoot: null,
      sourceMapWithCode: false,
      directive: false,
      raw: true,
      verbatim: null,
      sourceCode: null
    };
  };

  stringRepeat = function(str, num) {
    var result;
    result = "";
    num |= 0;
    while (num > 0) {
      if (num & 1) {
        result += str;
      }
      num >>>= 1;
      str += str;
    }
    return result;
  };

  hasLineTerminator = function(str) {
    return /[\r\n]/g.test(str);
  };

  endsWithLineTerminator = function(str) {
    var len;
    len = str.length;
    return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
  };

  merge = function(target, override) {
    var key;
    key = void 0;
    for (key in override) {
      if (override.hasOwnProperty(key)) {
        target[key] = override[key];
      }
    }
    return target;
  };

  updateDeeply = function(target, override) {
    var isHashObject, key, val;
    isHashObject = function(target) {
      return typeof target === "object" && target instanceof Object && (!(target instanceof RegExp));
    };
    key = void 0;
    val = void 0;
    for (key in override) {
      if (override.hasOwnProperty(key)) {
        val = override[key];
        if (isHashObject(val)) {
          if (isHashObject(target[key])) {
            updateDeeply(target[key], val);
          } else {
            target[key] = updateDeeply({}, val);
          }
        } else {
          target[key] = val;
        }
      }
    }
    return target;
  };

  generateNumber = function(value) {
    var exponent, point, pos, result, temp;
    result = void 0;
    point = void 0;
    temp = void 0;
    exponent = void 0;
    pos = void 0;
    if (value !== value) {
      throw new Error("Numeric literal whose value is NaN");
    }
    if (value < 0 || (value === 0 && 1 / value < 0)) {
      throw new Error("Numeric literal whose value is negative");
    }
    if (value === 1 / 0) {
      return (json ? "null" : (renumber ? "1e400" : "1e+400"));
    }
    result = "" + value;
    if (!renumber || result.length < 3) {
      return result;
    }
    point = result.indexOf(".");
    if (!json && result.charCodeAt(0) === 0x30 && point === 1) {
      point = 0;
      result = result.slice(1);
    }
    temp = result;
    result = result.replace("e+", "e");
    exponent = 0;
    if ((pos = temp.indexOf("e")) > 0) {
      exponent = +temp.slice(pos + 1);
      temp = temp.slice(0, pos);
    }
    if (point >= 0) {
      exponent -= temp.length - point - 1;
      temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
    }
    pos = 0;
    while (temp.charCodeAt(temp.length + pos - 1) === 0x30) {
      --pos;
    }
    if (pos !== 0) {
      exponent -= pos;
      temp = temp.slice(0, pos);
    }
    if (exponent !== 0) {
      temp += "e" + exponent;
    }
    if ((temp.length < result.length || (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length)) && +temp === value) {
      result = temp;
    }
    return result;
  };

  escapeRegExpCharacter = function(ch, previousIsBackslash) {
    if ((ch & ~1) === 0x2028) {
      return (previousIsBackslash ? "u" : "\\u") + (ch === 0x2028 ? "2028" : "2029");
    } else {
      if (ch === 10 || ch === 13) {
        return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
      }
    }
    return String.fromCharCode(ch);
  };

  generateRegExp = function(reg) {
    var ch, characterInBrack, flags, i, iz, match, previousIsBackslash, result;
    match = void 0;
    result = void 0;
    flags = void 0;
    i = void 0;
    iz = void 0;
    ch = void 0;
    characterInBrack = void 0;
    previousIsBackslash = void 0;
    result = reg.toString();
    if (reg.source) {
      match = result.match(/\/([^\/]*)$/);
      if (!match) {
        return result;
      }
      flags = match[1];
      result = "";
      characterInBrack = false;
      previousIsBackslash = false;
      i = 0;
      iz = reg.source.length;
      while (i < iz) {
        ch = reg.source.charCodeAt(i);
        if (!previousIsBackslash) {
          if (characterInBrack) {
            if (ch === 93) {
              characterInBrack = false;
            }
          } else {
            if (ch === 47) {
              result += "\\";
            } else {
              if (ch === 91) {
                characterInBrack = true;
              }
            }
          }
          result += escapeRegExpCharacter(ch, previousIsBackslash);
          previousIsBackslash = ch === 92;
        } else {
          result += escapeRegExpCharacter(ch, previousIsBackslash);
          previousIsBackslash = false;
        }
        ++i;
      }
      return "/" + result + "/" + flags;
    }
    return result;
  };

  escapeAllowedCharacter = function(code, next) {
    var hex;
    hex = void 0;
    if (code === 0x08) {
      return "\\b";
    }
    if (code === 0x0C) {
      return "\\f";
    }
    if (code === 0x09) {
      return "\\t";
    }
    hex = code.toString(16).toUpperCase();
    if (json || code > 0xFF) {
      return "\\u" + "0000".slice(hex.length) + hex;
    } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
      return "\\0";
    } else if (code === 0x000B) {
      return "\\x0B";
    } else {
      return "\\x" + "00".slice(hex.length) + hex;
    }
  };

  escapeDisallowedCharacter = function(code) {
    if (code === 0x5C) {
      return "\\\\";
    }
    if (code === 0x0A) {
      return "\\n";
    }
    if (code === 0x0D) {
      return "\\r";
    }
    if (code === 0x2028) {
      return "\\u2028";
    }
    if (code === 0x2029) {
      return "\\u2029";
    }
    throw new Error("Incorrectly classified character");
  };

  escapeDirective = function(str) {
    var code, i, iz, quote;
    i = void 0;
    iz = void 0;
    code = void 0;
    quote = void 0;
    quote = (quotes === "double" ? "\"" : "'");
    i = 0;
    iz = str.length;
    while (i < iz) {
      code = str.charCodeAt(i);
      if (code === 0x27) {
        quote = "\"";
        break;
      } else if (code === 0x22) {
        quote = "'";
        break;
      } else {
        if (code === 0x5C) {
          ++i;
        }
      }
      ++i;
    }
    return quote + str + quote;
  };

  escapeString = function(str) {
    var code, doubleQuotes, i, len, quote, result, single, singleQuotes;
    result = "";
    i = void 0;
    len = void 0;
    code = void 0;
    singleQuotes = 0;
    doubleQuotes = 0;
    single = void 0;
    quote = void 0;
    i = 0;
    len = str.length;
    while (i < len) {
      code = str.charCodeAt(i);
      if (code === 0x27) {
        ++singleQuotes;
      } else if (code === 0x22) {
        ++doubleQuotes;
      } else if (code === 0x2F && json) {
        result += "\\";
      } else if (esutils.code.isLineTerminator(code) || code === 0x5C) {
        result += escapeDisallowedCharacter(code);
        continue;
      } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20 || !json && !escapeless && (code < 0x20 || code > 0x7E))) {
        result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
        continue;
      }
      result += String.fromCharCode(code);
      ++i;
    }
    single = !(quotes === "double" || (quotes === "auto" && doubleQuotes < singleQuotes));
    quote = (single ? "'" : "\"");
    if (!(single ? singleQuotes : doubleQuotes)) {
      return quote + result + quote;
    }
    str = result;
    result = quote;
    i = 0;
    len = str.length;
    while (i < len) {
      code = str.charCodeAt(i);
      if ((code === 0x27 && single) || (code === 0x22 && !single)) {
        result += "\\";
      }
      result += String.fromCharCode(code);
      ++i;
    }
    return result + quote;
  };

  flattenToString = function(arr) {
    var elem, i, iz, result;
    i = void 0;
    iz = void 0;
    elem = void 0;
    result = "";
    i = 0;
    iz = arr.length;
    while (i < iz) {
      elem = arr[i];
      result += (isArray(elem) ? flattenToString(elem) : elem);
      ++i;
    }
    return result;
  };

  jswIndexes = [];

  origCode = null;

  toSourceNodeWhenNeeded = function(generated, node) {
    var jswIndex, md5, srcNode;
    if (!sourceMap) {
      if (isArray(generated)) {
        generated = flattenToString(generated);
      }
      return generated;
    }
    if (node == null) {
      if (generated instanceof SourceNode) {
        return generated;
      } else {
        node = {};
      }
    }
    if (node.loc == null) {
      srcNode = new SourceNode(null, null, sourceMap, generated, node.name || null);
      if (node && isStatement(node) && node.type !== 'Program') {
        if (createSrcNodesFile) {
          if (origCode == null) {
            origCode = fs.readFileSync('test/js-in.js', 'utf8');
          }
          fs.appendFileSync('test/srcNodes.txt', '\n##### ' + node.type + ': \n  ~' + origCode.slice(node.start, node.end) + '~\n  ~' + srcNode.toString() + '~\n');
        }
        md5 = crypto.createHash('md5').update(srcNode.toString());
        jswIndexes.push(jswIndex = {
          jswHash: md5.digest('hex'),
          jsStart: node.start,
          jsEnd: node.end
        });
      }
      return srcNode;
    }
    return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
  };

  noEmptySpace = function() {
    if (space) {
      return space;
    } else {
      return " ";
    }
  };

  join = function(left, right) {
    var leftCharCode, leftSource, rightCharCode, rightSource;
    leftSource = void 0;
    rightSource = void 0;
    leftCharCode = void 0;
    rightCharCode = void 0;
    leftSource = toSourceNodeWhenNeeded(left).toString();
    if (leftSource.length === 0) {
      return [right];
    }
    rightSource = toSourceNodeWhenNeeded(right).toString();
    if (rightSource.length === 0) {
      return [left];
    }
    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
    rightCharCode = rightSource.charCodeAt(0);
    if ((leftCharCode === 0x2B || leftCharCode === 0x2D) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 0x2F && rightCharCode === 0x69) {
      return [left, noEmptySpace(), right];
    } else {
      if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
        return [left, right];
      }
    }
    return [left, space, right];
  };

  addIndent = function(stmt) {
    return [base, stmt];
  };

  withIndent = function(fn) {
    var previousBase;
    previousBase = void 0;
    previousBase = base;
    base += indent;
    fn(base);
    return base = previousBase;
  };

  calculateSpaces = function(str) {
    var i;
    i = void 0;
    i = str.length - 1;
    while (i >= 0) {
      if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
        break;
      }
      --i;
    }
    return (str.length - 1) - i;
  };

  adjustMultilineComment = function(value, specialBase) {
    var array, i, j, len, line, previousBase, sn, spaces;
    array = void 0;
    i = void 0;
    len = void 0;
    line = void 0;
    j = void 0;
    spaces = void 0;
    previousBase = void 0;
    sn = void 0;
    array = value.split(/\r\n|[\r\n]/);
    spaces = Number.MAX_VALUE;
    i = 1;
    len = array.length;
    while (i < len) {
      line = array[i];
      j = 0;
      while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
        ++j;
      }
      if (spaces > j) {
        spaces = j;
      }
      ++i;
    }
    if (typeof specialBase !== "undefined") {
      previousBase = base;
      if (array[1][spaces] === "*") {
        specialBase += " ";
      }
      base = specialBase;
    } else {
      if (spaces & 1) {
        --spaces;
      }
      previousBase = base;
    }
    i = 1;
    len = array.length;
    while (i < len) {
      sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
      array[i] = (sourceMap ? sn.join("") : sn);
      ++i;
    }
    base = previousBase;
    return array.join("\n");
  };

  generateComment = function(comment, specialBase) {
    var result;
    if (comment.type === "Line") {
      if (endsWithLineTerminator(comment.value)) {
        return "//" + comment.value;
      } else {
        result = "//" + comment.value;
        if (!preserveBlankLines) {
          result += "\n";
        }
        return result;
      }
    }
    if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
      return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
    }
    return "/*" + comment.value + "*/";
  };

  addComments = function(stmt, result) {
    var comment, count, extRange, fragment, i, infix, len, prefix, prevRange, range, save, specialBase, suffix, tailingToStatement;
    i = void 0;
    len = void 0;
    comment = void 0;
    save = void 0;
    tailingToStatement = void 0;
    specialBase = void 0;
    fragment = void 0;
    extRange = void 0;
    range = void 0;
    prevRange = void 0;
    prefix = void 0;
    infix = void 0;
    suffix = void 0;
    count = void 0;
    if (stmt.leadingComments && stmt.leadingComments.length > 0) {
      save = result;
      if (preserveBlankLines) {
        comment = stmt.leadingComments[0];
        result = [];
        extRange = comment.extendedRange;
        range = comment.range;
        prefix = sourceCode.substring(extRange[0], range[0]);
        count = (prefix.match(/\n/g) || []).length;
        if (count > 0) {
          result.push(stringRepeat("\n", count));
          result.push(addIndent(generateComment(comment)));
        } else {
          result.push(prefix);
          result.push(generateComment(comment));
        }
        prevRange = range;
        i = 1;
        len = stmt.leadingComments.length;
        while (i < len) {
          comment = stmt.leadingComments[i];
          range = comment.range;
          infix = sourceCode.substring(prevRange[1], range[0]);
          count = (infix.match(/\n/g) || []).length;
          result.push(stringRepeat("\n", count));
          result.push(addIndent(generateComment(comment)));
          prevRange = range;
          i++;
        }
        suffix = sourceCode.substring(range[1], extRange[1]);
        count = (suffix.match(/\n/g) || []).length;
        result.push(stringRepeat("\n", count));
      } else {
        comment = stmt.leadingComments[0];
        result = [];
        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
          result.push("\n");
        }
        result.push(generateComment(comment));
        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push("\n");
        }
        i = 1;
        len = stmt.leadingComments.length;
        while (i < len) {
          comment = stmt.leadingComments[i];
          fragment = [generateComment(comment)];
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            fragment.push("\n");
          }
          result.push(addIndent(fragment));
          ++i;
        }
      }
      result.push(addIndent(save));
    }
    if (stmt.trailingComments) {
      if (preserveBlankLines) {
        comment = stmt.trailingComments[0];
        extRange = comment.extendedRange;
        range = comment.range;
        prefix = sourceCode.substring(extRange[0], range[0]);
        count = (prefix.match(/\n/g) || []).length;
        if (count > 0) {
          result.push(stringRepeat("\n", count));
          result.push(addIndent(generateComment(comment)));
        } else {
          result.push(prefix);
          result.push(generateComment(comment));
        }
      } else {
        tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
        i = 0;
        len = stmt.trailingComments.length;
        while (i < len) {
          comment = stmt.trailingComments[i];
          if (tailingToStatement) {
            if (i === 0) {
              result = [result, indent];
            } else {
              result = [result, specialBase];
            }
            result.push(generateComment(comment, specialBase));
          } else {
            result = [result, addIndent(generateComment(comment))];
          }
          if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result = [result, "\n"];
          }
          ++i;
        }
      }
    }
    return result;
  };

  generateBlankLines = function(start, end, result) {
    var j, newlineCount, results;
    j = void 0;
    newlineCount = 0;
    j = start;
    while (j < end) {
      if (sourceCode[j] === "\n") {
        newlineCount++;
      }
      j++;
    }
    j = 1;
    results = [];
    while (j < newlineCount) {
      result.push(newline);
      results.push(j++);
    }
    return results;
  };

  parenthesize = function(text, current, should) {
    if (current < should) {
      return ["(", text, ")"];
    }
    return text;
  };

  generateVerbatimString = function(string) {
    var i, iz, result;
    i = void 0;
    iz = void 0;
    result = void 0;
    result = string.split(/\r\n|\n/);
    i = 1;
    iz = result.length;
    while (i < iz) {
      result[i] = newline + base + result[i];
      i++;
    }
    return result;
  };

  generateVerbatim = function(expr, precedence) {
    var prec, result, verbatim;
    verbatim = void 0;
    result = void 0;
    prec = void 0;
    verbatim = expr[extra.verbatim];
    if (typeof verbatim === "string") {
      result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
    } else {
      result = generateVerbatimString(verbatim.content);
      prec = ((verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence);
      result = parenthesize(result, prec, precedence);
    }
    return toSourceNodeWhenNeeded(result, expr);
  };

  CodeGenerator = function() {};

  generateIdentifier = function(node) {
    return toSourceNodeWhenNeeded(node.name, node);
  };

  generateAsyncPrefix = function(node, spaceRequired) {
    if (node.async) {
      return "async" + (spaceRequired ? noEmptySpace() : space);
    } else {
      return "";
    }
  };

  generateStarSuffix = function(node) {
    var isGenerator;
    isGenerator = node.generator && !extra.moz.starlessGenerator;
    if (isGenerator) {
      return "*" + space;
    } else {
      return "";
    }
  };

  generateMethodPrefix = function(prop) {
    var func;
    func = prop.value;
    if (func.async) {
      return generateAsyncPrefix(func, !prop.computed);
    } else {
      if (generateStarSuffix(func)) {
        return "*";
      } else {
        return "";
      }
    }
  };

  generateInternal = function(node) {
    var codegen;
    codegen = void 0;
    codegen = new CodeGenerator();
    if (isStatement(node)) {
      return codegen.generateStatement(node, S_TFFF);
    }
    if (isExpression(node)) {
      return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
    }
    throw new Error("Unknown node type: " + node.type);
  };

  generate = function(node, options) {
    var defaultOptions, pair, result;
    rimraf.sync('test/srcNodes.txt');
    defaultOptions = getDefaultOptions();
    result = void 0;
    pair = void 0;
    if (options != null) {
      if (typeof options.indent === "string") {
        defaultOptions.format.indent.style = options.indent;
      }
      if (typeof options.base === "number") {
        defaultOptions.format.indent.base = options.base;
      }
      options = updateDeeply(defaultOptions, options);
      indent = options.format.indent.style;
      if (typeof options.base === "string") {
        base = options.base;
      } else {
        base = stringRepeat(indent, options.format.indent.base);
      }
    } else {
      options = defaultOptions;
      indent = options.format.indent.style;
      base = stringRepeat(indent, options.format.indent.base);
    }
    json = options.format.json;
    renumber = options.format.renumber;
    hexadecimal = (json ? false : options.format.hexadecimal);
    quotes = (json ? "double" : options.format.quotes);
    escapeless = options.format.escapeless;
    newline = options.format.newline;
    space = options.format.space;
    if (options.format.compact) {
      newline = space = indent = base = "";
    }
    parentheses = options.format.parentheses;
    semicolons = options.format.semicolons;
    safeConcatenation = options.format.safeConcatenation;
    directive = options.directive;
    parse = (json ? null : options.parse);
    sourceMap = options.sourceMap;
    sourceCode = options.sourceCode;
    preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
    extra = options;
    if (sourceMap) {
      if (!exports.browser) {
        SourceNode = require("source-map").SourceNode;
      } else {
        SourceNode = global.sourceMap.SourceNode;
      }
    }
    result = generateInternal(node);
    if (!sourceMap) {
      pair = {
        code: result.toString(),
        map: null
      };
      return (options.sourceMapWithCode ? pair : pair.code);
    }
    fs.writeFileSync('test/jswIndexes.json', JSON.stringify(jswIndexes));
    pair = result.toStringWithSourceMap({
      file: options.file,
      sourceRoot: options.sourceMapRoot
    });
    if (options.sourceContent) {
      pair.map.setSourceContent(options.sourceMap, options.sourceContent);
    }
    if (options.sourceMapWithCode) {
      return pair;
    }
    return pair.map.toString();
  };

  CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
    var noLeadingComment, result, that;
    result = void 0;
    noLeadingComment = void 0;
    that = this;
    noLeadingComment = !extra.comment || !stmt.leadingComments;
    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
      return [space, this.generateStatement(stmt, flags)];
    }
    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
      return "";
    }
    withIndent(function() {
      return result = [newline, addIndent(that.generateStatement(stmt, flags))];
    });
    return result;
  };

  CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {
    var ends;
    ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
      return [result, space];
    }
    if (ends) {
      return [result, base];
    }
    return [result, newline, base];
  };

  CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {
    if (node.type === Syntax.Identifier) {
      return generateIdentifier(node);
    }
    return this.generateExpression(node, precedence, flags);
  };

  CodeGenerator.prototype.generateFunctionParams = function(node) {
    var hasDefault, i, iz, result;
    i = void 0;
    iz = void 0;
    result = void 0;
    hasDefault = void 0;
    hasDefault = false;
    if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
      result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
    } else {
      result = (node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : []);
      result.push("(");
      if (node.defaults) {
        hasDefault = true;
      }
      i = 0;
      iz = node.params.length;
      while (i < iz) {
        if (hasDefault && node.defaults[i]) {
          result.push(this.generateAssignment(node.params[i], node.defaults[i], "=", Precedence.Assignment, E_TTT));
        } else {
          result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
        }
        if (i + 1 < iz) {
          result.push("," + space);
        }
        ++i;
      }
      if (node.rest) {
        if (node.params.length) {
          result.push("," + space);
        }
        result.push("...");
        result.push(generateIdentifier(node.rest));
      }
      result.push(")");
    }
    return result;
  };

  CodeGenerator.prototype.generateFunctionBody = function(node) {
    var expr, result;
    result = void 0;
    expr = void 0;
    result = this.generateFunctionParams(node);
    if (node.type === Syntax.ArrowFunctionExpression) {
      result.push(space);
      result.push("=>");
    }
    if (node.expression) {
      result.push(space);
      expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
      if (expr.toString().charAt(0) === "{") {
        expr = ["(", expr, ")"];
      }
      result.push(expr);
    } else {
      result.push(this.maybeBlock(node.body, S_TTFF));
    }
    return result;
  };

  CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {
    var result, that;
    result = ["for" + space + "("];
    that = this;
    withIndent(function() {
      if (stmt.left.type === Syntax.VariableDeclaration) {
        withIndent(function() {
          result.push(stmt.left.kind + noEmptySpace());
          return result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
        });
      } else {
        result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
      }
      result = join(result, operator);
      return result = [join(result, that.generateExpression(stmt.right, Precedence.Sequence, E_TTT)), ")"];
    });
    result.push(this.maybeBlock(stmt.body, flags));
    return result;
  };

  CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {
    var result;
    result = [];
    if (computed) {
      result.push("[");
    }
    result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));
    if (computed) {
      result.push("]");
    }
    return result;
  };

  CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {
    if (Precedence.Assignment < precedence) {
      flags |= F_ALLOW_IN;
    }
    return parenthesize([this.generateExpression(left, Precedence.Call, flags), space + operator + space, this.generateExpression(right, Precedence.Assignment, flags)], Precedence.Assignment, precedence);
  };

  CodeGenerator.prototype.semicolon = function(flags) {
    if (!semicolons && flags & F_SEMICOLON_OPT) {
      return "";
    }
    return "";
  };

  CodeGenerator.Statement = {
    BlockStatement: function(stmt, flags) {
      var content, range, result, that;
      range = void 0;
      content = void 0;
      result = ["", newline];
      that = this;
      withIndent(function() {
        var bodyFlags, fragment, i, iz, results;
        if (stmt.body.length === 0 && preserveBlankLines) {
          range = stmt.range;
          if (range[1] - range[0] > 2) {
            content = sourceCode.substring(range[0] + 1, range[1] - 1);
            if (content[0] === "\n") {
              result = [""];
            }
            result.push(content);
          }
        }
        i = void 0;
        iz = void 0;
        fragment = void 0;
        bodyFlags = void 0;
        bodyFlags = S_TFFF;
        if (flags & F_FUNC_BODY) {
          bodyFlags |= F_DIRECTIVE_CTX;
        }
        i = 0;
        iz = stmt.body.length;
        results = [];
        while (i < iz) {
          if (preserveBlankLines) {
            if (i === 0) {
              if (stmt.body[0].leadingComments) {
                range = stmt.body[0].leadingComments[0].extendedRange;
                content = sourceCode.substring(range[0], range[1]);
                if (content[0] === "\n") {
                  result = [""];
                }
              }
              if (!stmt.body[0].leadingComments) {
                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
              }
            }
            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
              if (i > 0) {
                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
              }
            }
          }
          if (i === iz - 1) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          if (stmt.body[i].leadingComments && preserveBlankLines) {
            fragment = that.generateStatement(stmt.body[i], bodyFlags);
          } else {
            fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
          }
          result.push(fragment);
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            if (preserveBlankLines && i < iz - 1) {
              if (!stmt.body[i + 1].leadingComments) {
                result.push(newline);
              }
            } else {
              result.push(newline);
            }
          }
          if (preserveBlankLines && i === iz - 1 && !stmt.body[i].trailingComments) {
            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
          }
          results.push(++i);
        }
        return results;
      });
      result.push(addIndent(""));
      return result;
    },
    BreakStatement: function(stmt, flags) {
      if (stmt.label) {
        return "break " + stmt.label.name + this.semicolon(flags);
      }
      return "break" + this.semicolon(flags);
    },
    ContinueStatement: function(stmt, flags) {
      if (stmt.label) {
        return "continue " + stmt.label.name + this.semicolon(flags);
      }
      return "continue" + this.semicolon(flags);
    },
    ClassBody: function(stmt, flags) {
      var result, that;
      result = ["{", newline];
      that = this;
      withIndent(function(indent) {
        var i, iz, results;
        i = void 0;
        iz = void 0;
        i = 0;
        iz = stmt.body.length;
        results = [];
        while (i < iz) {
          result.push(indent);
          result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
          if (i + 1 < iz) {
            result.push(newline);
          }
          results.push(++i);
        }
        return results;
      });
      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }
      result.push(base);
      result.push("}");
      return result;
    },
    ClassDeclaration: function(stmt, flags) {
      var fragment, result;
      result = void 0;
      fragment = void 0;
      result = ["class " + stmt.id.name];
      if (stmt.superClass) {
        fragment = join("extends", this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));
        result = join(result, fragment);
      }
      result.push(space);
      result.push(this.generateStatement(stmt.body, S_TFFT));
      return result;
    },
    DirectiveStatement: function(stmt, flags) {
      if (extra.raw && stmt.raw) {
        return stmt.raw + this.semicolon(flags);
      }
      return escapeDirective(stmt.directive) + this.semicolon(flags);
    },
    DoWhileStatement: function(stmt, flags) {
      var result;
      result = join("do", this.maybeBlock(stmt.body, S_TFFF));
      result = this.maybeBlockSuffix(stmt.body, result);
      return join(result, ["while" + space + "(", this.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ")" + this.semicolon(flags)]);
    },
    CatchClause: function(stmt, flags) {
      var result, that;
      result = void 0;
      that = this;
      withIndent(function() {
        var guard;
        guard = void 0;
        result = ["catch" + space + "(", that.generateExpression(stmt.param, Precedence.Sequence, E_TTT), ")"];
        if (stmt.guard) {
          guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
          return result.splice(2, 0, " if ", guard);
        }
      });
      result.push(this.maybeBlock(stmt.body, S_TFFF));
      return result;
    },
    DebuggerStatement: function(stmt, flags) {
      return "debugger" + this.semicolon(flags);
    },
    EmptyStatement: function(stmt, flags) {
      return "";
    },
    ExportDeclaration: function(stmt, flags) {
      var bodyFlags, result, that;
      result = ["export"];
      bodyFlags = void 0;
      that = this;
      bodyFlags = (flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
      if (stmt["default"]) {
        result = join(result, "default");
        if (isStatement(stmt.declaration)) {
          result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
        } else {
          result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
        }
        return result;
      }
      if (stmt.declaration) {
        return join(result, this.generateStatement(stmt.declaration, bodyFlags));
      }
      if (stmt.specifiers) {
        if (stmt.specifiers.length === 0) {
          result = join(result, "{" + space + "}");
        } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
          result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
        } else {
          result = join(result, "{");
          withIndent(function(indent) {
            var i, iz, results;
            i = void 0;
            iz = void 0;
            result.push(newline);
            i = 0;
            iz = stmt.specifiers.length;
            results = [];
            while (i < iz) {
              result.push(indent);
              result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
              if (i + 1 < iz) {
                result.push("," + newline);
              }
              results.push(++i);
            }
            return results;
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base + "}");
        }
        if (stmt.source) {
          result = join(result, ["from" + space, this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);
        } else {
          result.push(this.semicolon(flags));
        }
      }
      return result;
    },
    ExportDefaultDeclaration: function(stmt, flags) {
      stmt["default"] = true;
      return this.ExportDeclaration(stmt, flags);
    },
    ExportNamedDeclaration: function(stmt, flags) {
      return this.ExportDeclaration(stmt, flags);
    },
    ExpressionStatement: function(stmt, flags) {
      var fragment, isAsyncPrefixed, isClassPrefixed, isFunctionPrefixed, result;
      isClassPrefixed = function(fragment) {
        var code;
        code = void 0;
        if (fragment.slice(0, 5) !== "class") {
          return false;
        }
        code = fragment.charCodeAt(5);
        return code === 0x7B || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
      };
      isFunctionPrefixed = function(fragment) {
        var code;
        code = void 0;
        if (fragment.slice(0, 8) !== "function") {
          return false;
        }
        code = fragment.charCodeAt(8);
        return code === 0x28 || esutils.code.isWhiteSpace(code) || code === 0x2A || esutils.code.isLineTerminator(code);
      };
      isAsyncPrefixed = function(fragment) {
        var code, i, iz;
        code = void 0;
        i = void 0;
        iz = void 0;
        if (fragment.slice(0, 5) !== "async") {
          return false;
        }
        if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
          return false;
        }
        i = 6;
        iz = fragment.length;
        while (i < iz) {
          if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
            break;
          }
          ++i;
        }
        if (i === iz) {
          return false;
        }
        if (fragment.slice(i, i + 8) !== "function") {
          return false;
        }
        code = fragment.charCodeAt(i + 8);
        return code === 0x28 || esutils.code.isWhiteSpace(code) || code === 0x2A || esutils.code.isLineTerminator(code);
      };
      result = void 0;
      fragment = void 0;
      result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
      fragment = toSourceNodeWhenNeeded(result).toString();
      if (fragment.charCodeAt(0) === 0x7B || isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === "string")) {
        result = ["(", result, ")" + this.semicolon(flags)];
      } else {
        result.push(this.semicolon(flags));
      }
      return result;
    },
    ImportDeclaration: function(stmt, flags) {
      var cursor, result, that;
      result = void 0;
      cursor = void 0;
      that = this;
      if (stmt.specifiers.length === 0) {
        return ["import", space, this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];
      }
      result = ["import"];
      cursor = 0;
      if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
        result = join(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);
        ++cursor;
      }
      if (stmt.specifiers[cursor]) {
        if (cursor !== 0) {
          result.push(",");
        }
        if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
          result = join(result, [space, this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);
        } else {
          result.push(space + "{");
          if ((stmt.specifiers.length - cursor) === 1) {
            result.push(space);
            result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
            result.push(space + "}" + space);
          } else {
            withIndent(function(indent) {
              var i, iz, results;
              i = void 0;
              iz = void 0;
              result.push(newline);
              i = cursor;
              iz = stmt.specifiers.length;
              results = [];
              while (i < iz) {
                result.push(indent);
                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                if (i + 1 < iz) {
                  result.push("," + newline);
                }
                results.push(++i);
              }
              return results;
            });
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            result.push(base + "}" + space);
          }
        }
      }
      result = join(result, ["from" + space, this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);
      return result;
    },
    VariableDeclarator: function(stmt, flags) {
      var itemFlags;
      itemFlags = (flags & F_ALLOW_IN ? E_TTT : E_FTT);
      if (stmt.init) {
        return [this.generateExpression(stmt.id, Precedence.Assignment, itemFlags), space, "=", space, this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)];
      }
      return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
    },
    VariableDeclaration: function(stmt, flags) {
      var block, bodyFlags, i, iz, node, result, that;
      block = function() {
        var i, iz, node, results;
        node = stmt.declarations[0];
        if (extra.comment && node.leadingComments) {
          result.push("\n");
          result.push(addIndent(that.generateStatement(node, bodyFlags)));
        } else {
          result.push(noEmptySpace());
          result.push(that.generateStatement(node, bodyFlags));
        }
        i = 1;
        iz = stmt.declarations.length;
        results = [];
        while (i < iz) {
          node = stmt.declarations[i];
          if (extra.comment && node.leadingComments) {
            result.push("," + newline);
            result.push(addIndent(that.generateStatement(node, bodyFlags)));
          } else {
            result.push("," + space);
            result.push(that.generateStatement(node, bodyFlags));
          }
          results.push(++i);
        }
        return results;
      };
      result = void 0;
      i = void 0;
      iz = void 0;
      node = void 0;
      bodyFlags = void 0;
      that = this;
      result = [stmt.kind];
      bodyFlags = (flags & F_ALLOW_IN ? S_TFFF : S_FFFF);
      if (stmt.declarations.length > 1) {
        withIndent(block);
      } else {
        block();
      }
      result.push(this.semicolon(flags));
      return result;
    },
    ThrowStatement: function(stmt, flags) {
      return [join("throw", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
    },
    TryStatement: function(stmt, flags) {
      var guardedHandlers, i, iz, result;
      result = void 0;
      i = void 0;
      iz = void 0;
      guardedHandlers = void 0;
      result = ["try", this.maybeBlock(stmt.block, S_TFFF)];
      result = this.maybeBlockSuffix(stmt.block, result);
      if (stmt.handlers) {
        i = 0;
        iz = stmt.handlers.length;
        while (i < iz) {
          result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
          if (stmt.finalizer || i + 1 !== iz) {
            result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
          }
          ++i;
        }
      } else {
        guardedHandlers = stmt.guardedHandlers || [];
        i = 0;
        iz = guardedHandlers.length;
        while (i < iz) {
          result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
          if (stmt.finalizer || i + 1 !== iz) {
            result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
          }
          ++i;
        }
        if (stmt.handler) {
          if (isArray(stmt.handler)) {
            i = 0;
            iz = stmt.handler.length;
            while (i < iz) {
              result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
              if (stmt.finalizer || i + 1 !== iz) {
                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
              }
              ++i;
            }
          } else {
            result = join(result, this.generateStatement(stmt.handler, S_TFFF));
            if (stmt.finalizer) {
              result = this.maybeBlockSuffix(stmt.handler.body, result);
            }
          }
        }
      }
      if (stmt.finalizer) {
        result = join(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)]);
      }
      return result;
    },
    SwitchStatement: function(stmt, flags) {
      var bodyFlags, fragment, i, iz, result, that;
      result = void 0;
      fragment = void 0;
      i = void 0;
      iz = void 0;
      bodyFlags = void 0;
      that = this;
      withIndent(function() {
        return result = ["switch" + space + "(", that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT), ")" + space + "{" + newline];
      });
      if (stmt.cases) {
        bodyFlags = S_TFFF;
        i = 0;
        iz = stmt.cases.length;
        while (i < iz) {
          if (i === iz - 1) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
          result.push(fragment);
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            result.push(newline);
          }
          ++i;
        }
      }
      result.push(addIndent("}"));
      return result;
    },
    SwitchCase: function(stmt, flags) {
      var bodyFlags, fragment, i, iz, result, that;
      result = void 0;
      fragment = void 0;
      i = void 0;
      iz = void 0;
      bodyFlags = void 0;
      that = this;
      withIndent(function() {
        var results;
        if (stmt.test) {
          result = [join("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)), ":"];
        } else {
          result = ["default:"];
        }
        i = 0;
        iz = stmt.consequent.length;
        if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
          fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
          result.push(fragment);
          i = 1;
        }
        if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        bodyFlags = S_TFFF;
        results = [];
        while (i < iz) {
          if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
          result.push(fragment);
          if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            result.push(newline);
          }
          results.push(++i);
        }
        return results;
      });
      return result;
    },
    IfStatement: function(stmt, flags) {
      var bodyFlags, result, semicolonOptional, that;
      result = void 0;
      bodyFlags = void 0;
      semicolonOptional = void 0;
      that = this;
      withIndent(function() {
        return result = ["if" + space + "(", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ")"];
      });
      semicolonOptional = flags & F_SEMICOLON_OPT;
      bodyFlags = S_TFFF;
      if (semicolonOptional) {
        bodyFlags |= F_SEMICOLON_OPT;
      }
      if (stmt.alternate) {
        result.push(this.maybeBlock(stmt.consequent, S_TFFF));
        result = this.maybeBlockSuffix(stmt.consequent, result);
        if (stmt.alternate.type === Syntax.IfStatement) {
          result = join(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]);
        } else {
          result = join(result, join("else", this.maybeBlock(stmt.alternate, bodyFlags)));
        }
      } else {
        result.push(this.maybeBlock(stmt.consequent, bodyFlags));
      }
      return result;
    },
    ForStatement: function(stmt, flags) {
      var result, that;
      result = void 0;
      that = this;
      withIndent(function() {
        result = ["for" + space + "("];
        if (stmt.init) {
          if (stmt.init.type === Syntax.VariableDeclaration) {
            result.push(that.generateStatement(stmt.init, S_FFFF));
          } else {
            result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
            result.push(";");
          }
        } else {
          result.push(";");
        }
        if (stmt.test) {
          result.push(space);
          result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
          result.push(";");
        } else {
          result.push(";");
        }
        if (stmt.update) {
          result.push(space);
          result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
          return result.push(")");
        } else {
          return result.push(")");
        }
      });
      result.push(this.maybeBlock(stmt.body, (flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)));
      return result;
    },
    ForInStatement: function(stmt, flags) {
      return this.generateIterationForStatement("in", stmt, (flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
    },
    ForOfStatement: function(stmt, flags) {
      return this.generateIterationForStatement("of", stmt, (flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
    },
    LabeledStatement: function(stmt, flags) {
      return [stmt.label.name + ":", this.maybeBlock(stmt.body, (flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF))];
    },
    Program: function(stmt, flags) {
      var bodyFlags, fragment, i, iz, result;
      result = void 0;
      fragment = void 0;
      i = void 0;
      iz = void 0;
      bodyFlags = void 0;
      iz = stmt.body.length;
      result = [(safeConcatenation && iz > 0 ? "\n" : "")];
      bodyFlags = S_TFTF;
      i = 0;
      while (i < iz) {
        if (!safeConcatenation && i === iz - 1) {
          bodyFlags |= F_SEMICOLON_OPT;
        }
        if (preserveBlankLines) {
          if (i === 0) {
            if (!stmt.body[0].leadingComments) {
              generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
            }
          }
          if (i > 0) {
            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
              generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
            }
          }
        }
        fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
        result.push(fragment);
        if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
          if (preserveBlankLines) {
            if (!stmt.body[i + 1].leadingComments) {
              result.push(newline);
            }
          } else {
            result.push(newline);
          }
        }
        if (preserveBlankLines && i === iz - 1 && !stmt.body[i].trailingComments) {
          generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
        }
        ++i;
      }
      return result;
    },
    FunctionDeclaration: function(stmt, flags) {
      return [generateAsyncPrefix(stmt, true), "->", generateStarSuffix(stmt) || noEmptySpace(), generateIdentifier(stmt.id), this.generateFunctionBody(stmt)];
    },
    ReturnStatement: function(stmt, flags) {
      if (stmt.argument) {
        return [join("return", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
      }
      return ["return" + this.semicolon(flags)];
    },
    WhileStatement: function(stmt, flags) {
      var result, that;
      result = void 0;
      that = this;
      withIndent(function() {
        return result = ["while" + space + "(", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ")"];
      });
      result.push(this.maybeBlock(stmt.body, (flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)));
      return result;
    },
    WithStatement: function(stmt, flags) {
      var result, that;
      result = void 0;
      that = this;
      withIndent(function() {
        return result = ["with" + space + "(", that.generateExpression(stmt.object, Precedence.Sequence, E_TTT), ")"];
      });
      result.push(this.maybeBlock(stmt.body, (flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)));
      return result;
    }
  };

  merge(CodeGenerator.prototype, CodeGenerator.Statement);

  CodeGenerator.Expression = {
    SequenceExpression: function(expr, precedence, flags) {
      var i, iz, result;
      result = void 0;
      i = void 0;
      iz = void 0;
      if (Precedence.Sequence < precedence) {
        flags |= F_ALLOW_IN;
      }
      result = [];
      i = 0;
      iz = expr.expressions.length;
      while (i < iz) {
        result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
        if (i + 1 < iz) {
          result.push("," + space);
        }
        ++i;
      }
      return parenthesize(result, Precedence.Sequence, precedence);
    },
    AssignmentExpression: function(expr, precedence, flags) {
      return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
    },
    ArrowFunctionExpression: function(expr, precedence, flags) {
      return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
    },
    ConditionalExpression: function(expr, precedence, flags) {
      if (Precedence.Conditional < precedence) {
        flags |= F_ALLOW_IN;
      }
      return parenthesize([this.generateExpression(expr.test, Precedence.LogicalOR, flags), space + "?" + space, this.generateExpression(expr.consequent, Precedence.Assignment, flags), space + ":" + space, this.generateExpression(expr.alternate, Precedence.Assignment, flags)], Precedence.Conditional, precedence);
    },
    LogicalExpression: function(expr, precedence, flags) {
      return this.BinaryExpression(expr, precedence, flags);
    },
    BinaryExpression: function(expr, precedence, flags) {
      var currentPrecedence, fragment, leftSource, result;
      result = void 0;
      currentPrecedence = void 0;
      fragment = void 0;
      leftSource = void 0;
      currentPrecedence = BinaryPrecedence[expr.operator];
      if (currentPrecedence < precedence) {
        flags |= F_ALLOW_IN;
      }
      fragment = this.generateExpression(expr.left, currentPrecedence, flags);
      leftSource = fragment.toString();
      if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
        result = [fragment, noEmptySpace(), expr.operator];
      } else {
        result = join(fragment, expr.operator);
      }
      fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);
      if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
        result.push(noEmptySpace());
        result.push(fragment);
      } else {
        result = join(result, fragment);
      }
      if (expr.operator === "in" && !(flags & F_ALLOW_IN)) {
        return ["(", result, ")"];
      }
      return parenthesize(result, currentPrecedence, precedence);
    },
    CallExpression: function(expr, precedence, flags) {
      var i, iz, result;
      result = void 0;
      i = void 0;
      iz = void 0;
      result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
      result.push("(");
      i = 0;
      iz = expr["arguments"].length;
      while (i < iz) {
        result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
        if (i + 1 < iz) {
          result.push("," + space);
        }
        ++i;
      }
      result.push(")");
      if (!(flags & F_ALLOW_CALL)) {
        return ["(", result, ")"];
      }
      return parenthesize(result, Precedence.Call, precedence);
    },
    NewExpression: function(expr, precedence, flags) {
      var i, itemFlags, iz, length, result;
      result = void 0;
      length = void 0;
      i = void 0;
      iz = void 0;
      itemFlags = void 0;
      length = expr["arguments"].length;
      itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF);
      result = join("new", this.generateExpression(expr.callee, Precedence.New, itemFlags));
      if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
        result.push("(");
        i = 0;
        iz = length;
        while (i < iz) {
          result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
          if (i + 1 < iz) {
            result.push("," + space);
          }
          ++i;
        }
        result.push(")");
      }
      return parenthesize(result, Precedence.New, precedence);
    },
    MemberExpression: function(expr, precedence, flags) {
      var fragment, result;
      result = void 0;
      fragment = void 0;
      result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL ? E_TTF : E_TFF))];
      if (expr.computed) {
        result.push("[");
        result.push(this.generateExpression(expr.property, Precedence.Sequence, (flags & F_ALLOW_CALL ? E_TTT : E_TFT)));
        result.push("]");
      } else {
        if (expr.object.type === Syntax.Literal && typeof expr.object.value === "number") {
          fragment = toSourceNodeWhenNeeded(result).toString();
          if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
            result.push(".");
          }
        }
        result.push(".");
        result.push(generateIdentifier(expr.property));
      }
      return parenthesize(result, Precedence.Member, precedence);
    },
    UnaryExpression: function(expr, precedence, flags) {
      var fragment, leftCharCode, leftSource, result, rightCharCode;
      result = void 0;
      fragment = void 0;
      rightCharCode = void 0;
      leftSource = void 0;
      leftCharCode = void 0;
      fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
      if (space === "") {
        result = join(expr.operator, fragment);
      } else {
        result = [expr.operator];
        if (expr.operator.length > 2) {
          result = join(result, fragment);
        } else {
          leftSource = toSourceNodeWhenNeeded(result).toString();
          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
          rightCharCode = fragment.toString().charCodeAt(0);
          if (((leftCharCode === 0x2B || leftCharCode === 0x2D) && leftCharCode === rightCharCode) || (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {
            result.push(noEmptySpace());
            result.push(fragment);
          } else {
            result.push(fragment);
          }
        }
      }
      return parenthesize(result, Precedence.Unary, precedence);
    },
    YieldExpression: function(expr, precedence, flags) {
      var result;
      result = void 0;
      if (expr.delegate) {
        result = "yield*";
      } else {
        result = "yield";
      }
      if (expr.argument) {
        result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));
      }
      return parenthesize(result, Precedence.Yield, precedence);
    },
    AwaitExpression: function(expr, precedence, flags) {
      var result;
      result = join((expr.all ? "await*" : "await"), this.generateExpression(expr.argument, Precedence.Await, E_TTT));
      return parenthesize(result, Precedence.Await, precedence);
    },
    UpdateExpression: function(expr, precedence, flags) {
      if (expr.prefix) {
        return parenthesize([expr.operator, this.generateExpression(expr.argument, Precedence.Unary, E_TTT)], Precedence.Unary, precedence);
      }
      return parenthesize([this.generateExpression(expr.argument, Precedence.Postfix, E_TTT), expr.operator], Precedence.Postfix, precedence);
    },
    FunctionExpression: function(expr, precedence, flags) {
      var result;
      result = [generateAsyncPrefix(expr, true), "->"];
      if (expr.id) {
        result.push(generateStarSuffix(expr) || noEmptySpace());
        result.push(generateIdentifier(expr.id));
      } else {
        result.push(generateStarSuffix(expr) || space);
      }
      result.push(this.generateFunctionBody(expr));
      return result;
    },
    ExportBatchSpecifier: function(expr, precedence, flags) {
      return "*";
    },
    ArrayPattern: function(expr, precedence, flags) {
      return this.ArrayExpression(expr, precedence, flags, true);
    },
    ArrayExpression: function(expr, precedence, flags, isPattern) {
      var multiline, result, that;
      result = void 0;
      multiline = void 0;
      that = this;
      if (!expr.elements.length) {
        return "[]";
      }
      multiline = (isPattern ? false : expr.elements.length > 1);
      result = ["[", (multiline ? newline : "")];
      withIndent(function(indent) {
        var i, iz, results;
        i = void 0;
        iz = void 0;
        i = 0;
        iz = expr.elements.length;
        results = [];
        while (i < iz) {
          if (!expr.elements[i]) {
            if (multiline) {
              result.push(indent);
            }
            if (i + 1 === iz) {
              result.push(",");
            }
          } else {
            result.push((multiline ? indent : ""));
            result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
          }
          if (i + 1 < iz) {
            result.push("," + (multiline ? newline : space));
          }
          results.push(++i);
        }
        return results;
      });
      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }
      result.push((multiline ? base : ""));
      result.push("]");
      return result;
    },
    RestElement: function(expr, precedence, flags) {
      return "..." + this.generatePattern(expr.argument);
    },
    ClassExpression: function(expr, precedence, flags) {
      var fragment, result;
      result = void 0;
      fragment = void 0;
      result = ["class"];
      if (expr.id) {
        result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
      }
      if (expr.superClass) {
        fragment = join("extends", this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));
        result = join(result, fragment);
      }
      result.push(space);
      result.push(this.generateStatement(expr.body, S_TFFT));
      return result;
    },
    MethodDefinition: function(expr, precedence, flags) {
      var fragment, result;
      result = void 0;
      fragment = void 0;
      if (expr["static"]) {
        result = ["static" + space];
      } else {
        result = [];
      }
      if (expr.kind === "get" || expr.kind === "set") {
        fragment = [join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)), this.generateFunctionBody(expr.value)];
      } else {
        fragment = [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];
      }
      return join(result, fragment);
    },
    Property: function(expr, precedence, flags) {
      if (expr.kind === "get" || expr.kind === "set") {
        return [expr.kind, noEmptySpace(), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];
      }
      if (expr.shorthand) {
        return this.generatePropertyKey(expr.key, expr.computed);
      }
      if (expr.method) {
        return [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];
      }
      return [this.generatePropertyKey(expr.key, expr.computed), ":" + space, this.generateExpression(expr.value, Precedence.Assignment, E_TTT)];
    },
    ObjectExpression: function(expr, precedence, flags) {
      var fragment, multiline, result, that;
      multiline = void 0;
      result = void 0;
      fragment = void 0;
      that = this;
      if (!expr.properties.length) {
        return "{}";
      }
      multiline = expr.properties.length > 1;
      withIndent(function() {
        return fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
      });
      if (!multiline) {
        if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
          return ["{", space, fragment, space, "}"];
        }
      }
      withIndent(function(indent) {
        var i, iz, results;
        i = void 0;
        iz = void 0;
        result = ["{", newline, indent, fragment];
        if (multiline) {
          result.push("," + newline);
          i = 1;
          iz = expr.properties.length;
          results = [];
          while (i < iz) {
            result.push(indent);
            result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
            if (i + 1 < iz) {
              result.push("," + newline);
            }
            results.push(++i);
          }
          return results;
        }
      });
      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }
      result.push(base);
      result.push("}");
      return result;
    },
    ObjectPattern: function(expr, precedence, flags) {
      var i, iz, multiline, property, result, that;
      result = void 0;
      i = void 0;
      iz = void 0;
      multiline = void 0;
      property = void 0;
      that = this;
      if (!expr.properties.length) {
        return "{}";
      }
      multiline = false;
      if (expr.properties.length === 1) {
        property = expr.properties[0];
        if (property.value.type !== Syntax.Identifier) {
          multiline = true;
        }
      } else {
        i = 0;
        iz = expr.properties.length;
        while (i < iz) {
          property = expr.properties[i];
          if (!property.shorthand) {
            multiline = true;
            break;
          }
          ++i;
        }
      }
      result = ["{", (multiline ? newline : "")];
      withIndent(function(indent) {
        var results;
        i = void 0;
        iz = void 0;
        i = 0;
        iz = expr.properties.length;
        results = [];
        while (i < iz) {
          result.push((multiline ? indent : ""));
          result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
          if (i + 1 < iz) {
            result.push("," + (multiline ? newline : space));
          }
          results.push(++i);
        }
        return results;
      });
      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }
      result.push((multiline ? base : ""));
      result.push("}");
      return result;
    },
    ThisExpression: function(expr, precedence, flags) {
      return "this";
    },
    Super: function(expr, precedence, flags) {
      return "super";
    },
    Identifier: function(expr, precedence, flags) {
      return generateIdentifier(expr);
    },
    ImportDefaultSpecifier: function(expr, precedence, flags) {
      return generateIdentifier(expr.id || expr.local);
    },
    ImportNamespaceSpecifier: function(expr, precedence, flags) {
      var id, result;
      result = ["*"];
      id = expr.id || expr.local;
      if (id) {
        result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
      }
      return result;
    },
    ImportSpecifier: function(expr, precedence, flags) {
      return this.ExportSpecifier(expr, precedence, flags);
    },
    ExportSpecifier: function(expr, precedence, flags) {
      var exported, id, result;
      exported = (expr.id || expr.imported).name;
      result = [exported];
      id = expr.name || expr.local;
      if (id && id.name !== exported) {
        result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(id));
      }
      return result;
    },
    Literal: function(expr, precedence, flags) {
      var raw;
      raw = void 0;
      if (expr.hasOwnProperty("raw") && parse && extra.raw) {
        try {
          raw = parse(expr.raw).body[0].expression;
          if (raw.type === Syntax.Literal) {
            if (raw.value === expr.value) {
              return expr.raw;
            }
          }
        } catch (_error) {}
      }
      if (expr.value === null) {
        return "null";
      }
      if (typeof expr.value === "string") {
        return escapeString(expr.value);
      }
      if (typeof expr.value === "number") {
        return generateNumber(expr.value);
      }
      if (typeof expr.value === "boolean") {
        return (expr.value ? "true" : "false");
      }
      return generateRegExp(expr.value);
    },
    GeneratorExpression: function(expr, precedence, flags) {
      return this.ComprehensionExpression(expr, precedence, flags);
    },
    ComprehensionExpression: function(expr, precedence, flags) {
      var fragment, i, iz, result, that;
      result = void 0;
      i = void 0;
      iz = void 0;
      fragment = void 0;
      that = this;
      result = (expr.type === Syntax.GeneratorExpression ? ["("] : ["["]);
      if (extra.moz.comprehensionExpressionStartsWithAssignment) {
        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
        result.push(fragment);
      }
      if (expr.blocks) {
        withIndent(function() {
          var results;
          i = 0;
          iz = expr.blocks.length;
          results = [];
          while (i < iz) {
            fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
            if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
              result = join(result, fragment);
            } else {
              result.push(fragment);
            }
            results.push(++i);
          }
          return results;
        });
      }
      if (expr.filter) {
        result = join(result, "if" + space);
        fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
        result = join(result, ["(", fragment, ")"]);
      }
      if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
        result = join(result, fragment);
      }
      result.push((expr.type === Syntax.GeneratorExpression ? ")" : "]"));
      return result;
    },
    ComprehensionBlock: function(expr, precedence, flags) {
      var fragment;
      fragment = void 0;
      if (expr.left.type === Syntax.VariableDeclaration) {
        fragment = [expr.left.kind, noEmptySpace(), this.generateStatement(expr.left.declarations[0], S_FFFF)];
      } else {
        fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
      }
      fragment = join(fragment, (expr.of ? "of" : "in"));
      fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
      return ["for" + space + "(", fragment, ")"];
    },
    SpreadElement: function(expr, precedence, flags) {
      return ["...", this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)];
    },
    TaggedTemplateExpression: function(expr, precedence, flags) {
      var itemFlags, result;
      itemFlags = E_TTF;
      if (!(flags & F_ALLOW_CALL)) {
        itemFlags = E_TFF;
      }
      result = [this.generateExpression(expr.tag, Precedence.Call, itemFlags), this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)];
      return parenthesize(result, Precedence.TaggedTemplate, precedence);
    },
    TemplateElement: function(expr, precedence, flags) {
      return expr.value.raw;
    },
    TemplateLiteral: function(expr, precedence, flags) {
      var i, iz, result;
      result = void 0;
      i = void 0;
      iz = void 0;
      result = ["`"];
      i = 0;
      iz = expr.quasis.length;
      while (i < iz) {
        result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
        if (i + 1 < iz) {
          result.push("${" + space);
          result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
          result.push(space + "}");
        }
        ++i;
      }
      result.push("`");
      return result;
    },
    ModuleSpecifier: function(expr, precedence, flags) {
      return this.Literal(expr, precedence, flags);
    }
  };

  merge(CodeGenerator.prototype, CodeGenerator.Expression);

  CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {
    var result, type;
    result = void 0;
    type = void 0;
    type = expr.type || Syntax.Property;
    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
      return generateVerbatim(expr, precedence);
    }
    result = this[type](expr, precedence, flags);
    if (extra.comment) {
      result = addComments(expr, result);
    }
    return toSourceNodeWhenNeeded(result, expr);
  };

  jswIndexes = [];

  CodeGenerator.prototype.generateStatement = function(stmt, flags) {
    var fragment, result;
    result = void 0;
    fragment = void 0;
    result = this[stmt.type](stmt, flags);
    if (extra.comment) {
      result = addComments(stmt, result);
    }
    fragment = toSourceNodeWhenNeeded(result).toString();
    if (stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === "\n") {
      result = (sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, ""));
    }
    return toSourceNodeWhenNeeded(result, stmt);
  };

  FORMAT_MINIFY = {
    indent: {
      style: "",
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: "auto",
    escapeless: true,
    compact: true,
    parentheses: false,
    semicolons: false
  };

  FORMAT_DEFAULTS = getDefaultOptions().format;

  exports.generate = generate;

  exports.attachComments = estraverse.attachComments;

  exports.Precedence = updateDeeply({}, Precedence);

  exports.browser = false;

  exports.FORMAT_MINIFY = FORMAT_MINIFY;

  exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;

}).call(this);
